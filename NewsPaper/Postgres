# Импортировать пакет psycopg2
import psycopg2

# Открыть подключение к базе.
# Обратите внимание на синтаксис строки с информацией о БД:
# если вы меняли настройки своей БД, то и здесь их придется
# указать соответствующие.
# Кстати, таких подключений можно открывать сколько угодно:
# вдруг у вашего приложения данные распределены
# по нескольким базам?
conn = psycopg2.connect("dbname=postgres user=postgres")

# Создать «курсор» на подключении к базе.
# Курсоры используются для представления
# сессий подключения к БД.
cur = conn.cursor()

# Выполнить команду напрямую.
cur.execute(
    "CREATE TABLE test (id serial PRIMARY KEY, num integer, data varchar);"
)

# Выполнить команду, не заботясь о корректном синтаксисе
# представления данных: psycopg2 всё сделает за нас.
cur.execute(
    "INSERT INTO test (num, data) VALUES (%s, %s)",
    (100, "abc'def")
)

# Выполнить команду
cur.execute("SELECT * FROM test;")
# Но как получить результат её выполнения?..

# А вот так. fetchone — «принести» одну строчку результата,
# fetchall — все строчки.
cur.fetchone()

# Завершить транзакцию
conn.commit()
# Закрыть курсор
cur.close()
# Закрыть подключение
conn.close()


#############################################################################
Для начала коротко о том, как настроить Django для работы с Postgres.

Это делается достаточно просто: в вашем файле settings.py необходимо в словаре DATABASES прописать данные вашей БД примерно следующим образом:

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'postgres',
        'USER': 'postgres',
        'PASSWORD': '',
        'HOST': 'localhost',
        'PORT': '5432',
    },
}
Здесь есть следующие параметры:

ENGINE — это путь импорта специального модуля Django, отвечающего за работу с конкретным типом БД — «бэкенда БД»
По умолчанию в версии Django 3.1 доступны:
  - django.db.backends.sqlite3 — для работы с БД типа SQLite3;

  - django.db.backends.postgresql — для работы с обсуждаемым нами Postgres;

-  django.db.backends.mysql для MySQL;

-  django.db.backends.oracle для Oracle.

Но существует множество других бэкендов БД, написанных как авторами Django, так и другими программистами.

NAME — имя вашей базы данных (в нашем примере это postgres, но если вы назвали вашу БД по-другому, то это то значение,
которое вы видите при выполнении команды \list в утилите psql).
USER — имя пользователя БД.
PASSWORD — пароль пользователя БД.
HOST — сетевой адрес БД; если вы работаете локально, то, скорее всего, это просто localhost.
PORT — порт БД; у PostgreSQL по умолчанию это 5432.
Вы уже знаете, что код моделей на Python транслируется в SQL за вас, и поэтому писать код на SQL, работая на Django,
вам не нужно. Однако знать о том, как это происходит, важно как минимум для того, чтобы понимать, как вы можете
оптимизировать работу вашего приложения с базой. Кое-что из того, о чем мы будем говорить ниже, вам уже знакомо из
предыдущих модулей, поэтому мы не будем слишком углубляться в детали.

Когда вы впервые написали код ваших моделей, вам необходимо создать так называемые миграции базы данных, чтобы Django
могла синхронизировать ваш код со структурой таблиц в БД. Допустим, вы написали следующую модель:

class Author(models.Model):
    name = models.CharField(
        default='NoName',
        max_length=64,
        verbose_name='name of author'
    )
Здесь всё просто: модель автора пока имеет единственное поле — имя. Оно имеет тип CharField, его максимальная длина — 64,
а значение по умолчанию — NoName. Чтобы создать миграции БД, вы можете выполнить специальную команду python manage.py
makemigrations. В результате её выполнения в вашем приложении в папке migrations появится файл, название которого будет,
скорее всего, начинаться на «0001», в котором будет определен Python-класс.

