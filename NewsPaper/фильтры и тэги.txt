Встроенные тэги


autoescape

Помните, в модуле о безопасности изучались различные методы усиления защиты сайта?

В качестве инструмента, который уже встроен в Django, мы упоминали экранирование HTML-кода. Если вы, например, в форму
вставите HTML-код и отправите его POST-запросом на сервер, то он заменит управляющие символы (такие, как угловые
<скобки>) на их специальные коды. И тогда при последующем выводе этих данных они будут выглядеть именно как код,
а не рендериться в соответствии с тем, что написано в коде. Иными словами, будут выводиться просто как текст.

Этот метод по умолчанию регулируется тэгом autoescape со значением on. Посмотрим, как он выглядит:

{% autoescape on %}
    {{ something }}
{% endautoescape %}
Для включения экранирования ничего делать не нужно, оно всегда включено автоматически. Однако, если для каких-то ваших
целей необходимо выключить автоэкранирование, то нужную часть кода можно поместить внутри тэга autoescape
со значением off.

Будьте осторожны! Это действие создает брешь в безопасности сайта!


comment

Хоть это и является плохой практикой, но программисты в процессе разработки любят ставить части кода внутри комментариев,
чтобы данный код не исполнялся. Но, конечно же, комментарии служат в первую очередь для создания комментариев к коду,
поясняющие его смысл (удивительно, не правда ли?).

Вне зависимости от цели применения Django также поддерживает создание комментариев с помощью тэга comment:

{% comment "Comment" %}
    <p>ignore it</p>
{% endcomment %}
Есть и другой подход к комментариям — с помощью специального HTML-тэга (не путать с Django-тэгами) <!-- -->, но его
использование не останавливает выполнение Django собственного кода внутри этого блока, он только скрывает его от конечного
пользователя. Код внутри comment не исполняется вообще.


csrf_token

С этим тэгом вы уже хорошо знакомы, он обеспечивает защиту от CSRF-угроз. Они возникают, когда злоумышленники пытаются
подделать данные формы, которые отправляются POST-запросом на сервер.


cycle

А вот это уже что-то интересное. Задумывались ли вы о том, как можно сделать вывод таблицы с чередующимися цветами в
строках? Например так, как в Google-таблицах (или Excel).

В этих специальных приложениях чередование цветов в строках делается нажатием буквально двух кнопок.

Как же это сделать в Django-шаблонах? Для этого можно применить цикл в цикле. Звучит страшно, наверное.

Допустим, у вас есть цикл, который формирует строки таблицы:

{% for obj in array %}
    <tr>
        <td> {{ obj.col1 }} </td>
        <td> ...
    </tr>
{% endfor %}
Цвет строки обычно регулируется в классах стилей. Если вы с ними до сих пор еще не знакомы, не страшно, уже скоро мы
познакомимся и с ними. А сейчас можно просто запомнить, что где-то кем-то определены два стиля white и blue, которые
раскрашивают строку соответственно белым и голубым (как на картинке выше). В таком случае внутри цикла строк можно
запустить еще один псевдоцикл, который будет «мигать» по этим двум значениям до тех пор, пока работает основной цикл.

{% for obj in array %}
    <tr class="{% cycle 'blue' 'white' %}">
        <td> {{ obj.col1 }} </td>
        <td> ...
    </tr>
{% endfor %}
Тогда для первой строки будет применен стиль blue, для второй — white, для третьей — снова blue и т. д. Удобно?
Особенно удобно тем, что можно использовать не только два объекта для итерации, а сколько угодно.


firstof

Бывает такое, что в шаблон передается несколько переменных и нужно выбрать одну из них, которая принимает значение
не False  (в т. ч. и пустые строки, пустые списки и т. д.). Для этого на помощь приходит тэг firstof.

{% firstof var1 var2 var3 %}
Его использование эквивалентно громоздкой конструкции if .. elif .. else. В предлагаемом варианте также можно установить
дефолтное значение, которое будет использоваться, если все переменные эквивалентны False.

{% firstof var1 var2 var3 "default_value" %}
for … empty
С обычным циклом for мы хорошо знакомы. Однако в реальных ситуациях бывает так, что итерируемый объект (список,
например) оказывается пустым. Ранее предлагалась конструкция с проверкой на существование:

{% if array %}
    {% for t in array %}
        do_something
    {% endfor %}
{% else %}
    Список пуст
{% endif %}
Громоздко и нечитабельно, поэтому у тэга for есть дополнительное свойство. Предыдущая конструкция эквивалентна этой:

{% for t in array %}
    do_something
{% empty %}
    Список пуст
{% endfor %}
Она позволяет более лаконично писать код.


NB:
Интересная фишка, на которую можно обратить внимание между делом. Почему второй вариант кажется более привлекательным? С одной стороны, очевидно, что меньше строк, и более понятная логика. Но здесь большую роль играет стиль написания кода, а именно отступы. В первом случае информативный блок (тело цикла) находится на третьем уровне отступов, а дефолтный блок («Список пуст») — на втором. Кажется мелочью, но когда таких кусков кода становится много, а если они еще и вложены друг в друга, то уловить общую логику становится невероятно сложно, потому что нужно отслеживать отступы, начало и концы операторов (тэгов в данном случае). Однако во втором примере кода и информативный блок, и дефолтный находятся на одном уровне отступов, и это позволяет сильно увеличить читабельность кода. В Python отступы играют решающую роль даже с точки зрения синтаксиса. HTML и Django-код внутри шаблонов не так жестко привязаны к отступам, и поэтому есть соблазн не соблюдать какие-то стилистические правила. Однако в будущем это может сыграть с вами или вашими коллегами злую шутку.

ifchanged
Данный тэг используется в циклах для выполнения кода только при наличии изменений. Есть два способа его применения. Первый используется без аргументов, и тогда рендеринг происходит, только если содержимое внутри тэга подверглось изменениям.

{% for t in array %}
    {% ifchanged %} Вывести значение {{ t.key }} {% endifchanged %}
    do something in loop
{% endfor %}
Этот вариант действует на весь контент внутри тэга, но можно вручную контролировать изменения данных, если использовать аргументы.

{% for t in array %}
    {% ifchanged t.key %} Вывести значение {{ t.key }} {% endifchanged %}
    do something in loop
{% endfor %}
Тэг удобен, когда нужно выводить списки по категориям и, например, сначала вывести название категории, а потом список
объектов этой категории. Как, например, в словарях — сначала первая буква жирным шрифтом, а потом — все слова на эту букву.


include

Ранее нами использовались тэги block и extend для разбиения кода шаблона на несколько файлов. Имелась возможность
выстраивать структуру наследования шаблонов для сокращения повторения кода. Тэг include позволяет встроить какой-то
HTML-код (из другого файла) в текущий без встраивания в общую структуру наследования. Иногда это бывает крайне полезно.
Особенность заключается в том, что контекст, используемый в основном файле, передается также и в файл, который
«импортируется» с помощью тэга include. Таким образом можно писать контекстно-независимые куски HTML-кода, которые
могут быть применены в разных других основных файлах и рендериться в зависимости от текущего контекста.

Для подобного «включения» нужно указать название файла от корня папки шаблонов:

{% include "foo/bar.html" %}
load
К этому тэгу мы вернемся в следующей части этой темы, ведь он позволяет использовать собственные тэги и фильтры.
Мы будем их создавать в .py файлах, а тэг load позволяет указать в шаблоне, из какого файла их нужно брать:

{% load package.customtags %}
Тэги, загруженные в данный шаблон, действуют в нем и во всех унаследованных от него шаблонах (с помощью тэгов block и extends).


url

Еще один знакомый вам тэг, который позволяет вставлять ссылки по их имени в URL patterns. На всякий случай вспомним,
как он работает. Допустим, в главном файле urls.py есть подключение URL из приложения:

path('client/', include('project_name.app_name.urls'))
А в файле конфигурации URL самого приложения следующее:

path('client/<int:id>/', app_views.client, name='app-views-client')
В таком случае в шаблоне вы можете вставлять ссылку, используя тэг url:

{% url 'app-views-client' cliend.id %}
Если URL не принимает никаких аргументов, то достаточно указать только его name. Если же URL обязательно должен получить
один (или несколько) параметров, то их вставка внутри тэга обязательна, как в примере выше. Если это не будет выполнено,
 то Django выбросит исключение NoReverseMatch, что говорит о том, что Django не справился с тем, чтобы найти нужный
 URL-шаблон для данного имени и набора параметров.


with

Последний тэг, с которым мы познакомимся — это тэг создания контекстных переменных. Часто при использовании данных внутри
шаблонов приходится писать длинные конструкции с большим количеством точек по типу: object.other_object.field.method.
Это неудобно и неэффективно. Тэг with позволяет кэшировать подобные, часто используемые, переменные, используя более короткие имена:

{% with my_method = object.other_object.field.method %}
    do something with my_method
{% endwith %}
Естественно, даже этим списком встроенные тэги не ограничиваются. Здесь был проведен обзор наиболее часто используемых
тэгов, а со всеми остальными можно познакомиться в соответствующем разделе документации.

------------------------------------------------------------
Встроенные фильтры
Про фильтры уже многое было сказано, поэтому лишь организуем их в виде таблицы с небольшими пояснениями.

Фильтр	        Цель	        Пример
add	        Добавляет аргумент к значению.      Поддерживает операции сложения из Python: числа, строки, списки.	{{ value|add:"2" }}
capfirst	Заменяет регистр первого символа на верхний.	        {{ value| capfirst}}    django -> Django
cut	        Удаляет все символы из строки.	        {{ value|cut:" " }} удалит все пробелы
date	    Форматирует дату согласно шаблону.	    {{ value|date:"D d M Y" }}
default	    Использовать дефолтное значение, если value==False.     	{{ value|default:"nothing" }}
default_if_none	        Использовать дефолтное значение, если None.	    {{ value|default_is_none:"nothing" }}
first	    Возвращает первый элемент списка.	    {{ value|first }}   Если value=[1,2,3], то вернется 1
floatformat	    Форматирует числа с плавающей точкой.	    {{ value|floatformat:2 }}   Если value=32.23234, то будет 32.23
join	        Действует как Python-функция join.	        {{ value|join:" // " }}
last	    Аналогично first, только для последнего.	    {{ value|last }}
length	    Возвращает длину списка.	                    {{ value|length }}
linenumbers	    Вставляет нумерацию для элементов списка.	{{ value|linenumbers }}
lower	    Понижает регистр во всей строке.	            {{ value|lower }}
random	    Возвращает случайное значение списка.	        {{ value|random }}
slice	    Делает Python-срез списка.	                    {{ some_list|slice:":2" }}
time	    Аналогично фильтру date.	                    {{ value|time:"H:i" }}
truncatechars	    Обрезает текст по количеству символов.	{{ value|truncatechars:7 }}
truncatewords	    Обрезает текст по количеству слов.	    {{ value|truncatewords:2 }}
upper	    Аналогично lower, только повышает регистр.	    {{ value|upper }}
yesno	    Позволяет заменить True, False и None на более привычные строки.	{{ value|yesno:"yeah,no,maybe" }}



Создание собственных тэгов и фильтров
Этот вопрос нами уже обсуждался ранее при первом разговоре про шаблоны. Напомним, что для создания собственных фильтров мы должны сделать следующие шаги:

В приложении проекта создать директорию templatetags.

Добавить в ней пустой файл __init__.py.
Создать файл, например, custom_extras.py.
В шаблоне прописать {% load custom_extras %}.

В самом файле custom_extras.py необходимо импортировать библиотеку шаблонов:

from django import template

register = template.Library()
Объект register содержит декораторы, благодаря которым можно оборачивать функции в фильтры или тэги. Например, рассмотренный нами фильтр lower будет выглядеть так:

@register.filter
def lower(value):
    return value.lower()
Для регистрации собственного тэга необходимо использовать другой декоратор simple_tag:

@register.simple_tag
def current_time(format_string):
    return datetime.datetime.now().strftime(format_string)
Данный тэг вернет текущее время в формате, который передается в качестве аргумента тэга.

Что важно знать про создание собственных тэгов?
Django самостоятельно осуществляет проверку наличия обязательных аргументов. Вам не нужно беспокоиться о проверках.
В функцию можно передавать переменные из шаблонов.
Функция также может использовать контекст шаблона. Для этого необходимо добавить аргументы у декоратора и самой функции.
@register.simple_tag(takes_context = True)
def func(context, other_arg):
    pass
Название тэга, используемое в самом шаблоне, может отличаться от названия функции. Для указания иного имени нужно
добавить соответствующий аргумент в декоратор.
@register.simple_tag(takes_context = True, name = "tagname")
def func(context, other_arg):
    pass
Декоратор simple_tag позволяет удовлетворять основные потребности в создании собственных тэгов, однако этим возможности
Django не ограничиваются. Фреймворк также позволяет создавать включающие тэги с помощью декоратора inclusion_tag.
Они позволяют определять контекстно-зависимые шаблоны, которые могут использоваться внутри основного шаблона.
Иными словами, вы логикой Python создаете поведение шаблона в зависимости от контекста. Также поддерживается создание
собственных тэгов с нуля, но это задача не из тривиальных, поэтому предлагается ознакомиться с этим подходом
самостоятельно, если возникнет желание и/или потребность.


---------------------------------------------------------------------
Задание 13.2.6
Реализуйте фильтр, который заменяет все буквы кроме первой и последней на «*» у слов из списка «нежелательных». Предполагается, что в качестве аргумента гарантированно передается текст, и слова разделены пробелами. Можно считать, что запрещенные слова находятся в списке forbidden_words.

Ответ

@register.filter
def hide_forbidden(value):
    words = value.split()
    result = []
    for word in words:
        if word in forbidden_words:
            result.append(word[0] + "*"*(len(word)-2) + word[-1])
        else:
            result.append(word)
    return " ".join(result)